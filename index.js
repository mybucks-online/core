import { Buffer } from "buffer";
import { ethers } from "ethers";
import scryptJS from "scrypt-js";
import { nanoid } from "nanoid";
import { TronWeb } from "tronweb";

const { scrypt } = scryptJS;
const abi = new ethers.AbiCoder();

const HASH_OPTIONS = {
  N: 32768, // CPU/memory cost parameter, 2^15
  r: 8, // block size parameter
  p: 5, // parallelization parameter
  keyLen: 64,
};

/**
 * This function computes the scrypt hash using provided password and passcode inputs.
 *
 * @param {*} password
 * @param {*} passcode
 * @param {*} cb a callback function designed to receive the progress updates during the scrypt hashing process.
 * @returns hash result as string format
 */
export async function generateHash(password, passcode, cb = () => {}) {
  if (!password || !passcode) {
    return "";
  }

  const salt = `${password.slice(-4)}${passcode}`;

  const passwordBuffer = Buffer.from(password);
  const saltBuffer = Buffer.from(salt);

  const hashBuffer = await scrypt(
    passwordBuffer,
    saltBuffer,
    HASH_OPTIONS.N,
    HASH_OPTIONS.r,
    HASH_OPTIONS.p,
    HASH_OPTIONS.keyLen,
    cb
  );

  return Buffer.from(hashBuffer).toString("hex");
}

/**
 * This function derives the EVM private key from a result of the scrypt hash.
 * @param {*} hash scrypt hash result
 * @returns private key as string format
 */
export function getEvmPrivateKey(hash) {
  return ethers.keccak256(abi.encode(["string"], [hash]));
}

/**
 * This function returns the EVM wallet address from a result of the scrypt hash.
 * @param {*} hash scrypt hash result
 * @returns address as string format
 */
export function getEvmWalletAddress(hash) {
  const privateKey = getEvmPrivateKey(hash);
  const wallet = new ethers.Wallet(privateKey);
  return wallet.address;
}

/**
 * This function returns the TRON wallet address from a result of the scrypt hash.
 * @param {*} hash scrypt hash result
 * @returns address as string format
 */
export function getTronWalletAddress(hash) {
  const privateKey = getEvmPrivateKey(hash);
  return TronWeb.address.fromPrivateKey(privateKey.slice(2));
}

const URL_DELIMITER = "\u0002";
const NETWORKS = [
  "ethereum",
  "polygon",
  "arbitrum",
  "optimism",
  "bsc",
  "avalanche",
  "base",
  "tron",
];
/**
 * This function generates a transfer-link by combining credentials and randomly generated padding.
 * The transfer-link introduces a nice feature that enables the transfer of full ownership of a wallet account.
 * @param {*} password
 * @param {*} passcode
 * @param {*} network ethereum | polygon | arbitrum | optimism | bsc | avalanche | base | tron
 * @returns A string formatted as a transfer-link token, which can be appended to `https://app.mybucks.online?wallet=`
 */
export function generateToken(password, passcode, network) {
  if (!password || !passcode || !network) {
    return null;
  }
  if (!NETWORKS.find((n) => n === network)) {
    return null;
  }

  const merged = Buffer.from(
    password + URL_DELIMITER + passcode + URL_DELIMITER + network,
    "utf-8"
  );
  const base64Encoded = merged.toString("base64");
  const padding = nanoid(12);
  return padding.slice(0, 6) + base64Encoded + padding.slice(6);
}

/**
 * This function parses a transfer-link token generated by generateToken().
 * @param {*} token
 * @returns an array of strings, including the password, passcode and network.
 */
export function parseToken(token) {
  const payload = token.slice(6, token.length - 6);
  const base64Decoded = Buffer.from(payload, "base64").toString("utf-8");
  const [password, passcode, network] = base64Decoded.split(URL_DELIMITER);
  return [password, passcode, network];
}
